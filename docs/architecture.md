# KinkLink Architecture

## Notable Technologies and Libraries

### Server

- **Server Framework**: ASP.NET Core 8.0, 9.0, 10.0
- **Database**: PostgreSQL
- **Real-time Communication**: SignalR with MessagePack protocol
- **Logging**: Serilog with structured JSON logging
- **Monitoring**: Grafana/Prometheus metrics supported
- **ORM**: Sqlc which generates the Npgsql queries from raw sql
- **Discord Integration**: Discord.Net

### Client Stack

- **Framework**: .NET 10.0-windows
- **Game Integration**: Dalamud.NET SDK 14.0.1
- **UI Framework**: ImGui (via Dalamud)
- **Real-time Communication**: SignalR Client
- **External APIs**:
  - Glamourer IPC
  - Penumbra IPC 5.13.1
  - CustomizePlus IPC
  - Honorific IPC
  - Moodles IPC

## Patterns

In KinkLink it uses a pattern inherited from AetherRemote that is as follows:

`Handlers` react to asynchronous events and trigger actions/events
`Managers` organize and orchestrate functionality across services
`Services` orchestrate dalamud/IPC calls for functionality.
`Hooks/IPC/Dalamud APIs` are the low level commands which actually cause side effects to the gamestate

Currently, the pattern is "call down the heirarchy", and "signal with events up the heirarchy".

Calling down looks like:

- `Handlers` can all anything below it (though typically `Managers` and `Services`)
- `Managers` can call `Services`
- `Services` only call `hooks`, `ipc`, and `Dalamud`

Signaling up

- `Handlers` can listen to events from `Managers`, `Services` and `Hooks/Dalamud` and don't typically emit events
- `Managers` listen to events from `Services` and `Hooks/Dalamud` and emit events that need to go to handlers
- `Services` listen to events from `hooks`, `ipc`, and `Dalamud` and emit events that can be listened to above

For network connectivity, this remains true as well. `Handlers` listen to the PrimaryHub and `Services` send network requests as needed.

KinkLink leverages dependency injection to sort out the dependencies, when adding new modules, these need to be added to `Plugin.cs` to ensure that they are booted properly.

When subscripting to an event for your module in the constructor (e.g. `class MyModule(T module) {}` be sure to initialize that module _at least once_ using `_services.GetRequiredService<T>();`

### Practical Example: Global Chat

KinkLink supports a little anonymous global chat in the main menu. While this does not interact with the gamestate, it does follow the full end to end flow.

#### Sender flow

1. `ChatUiView`/`ChatUiController` gets the user input message and a keyboard enter/button click
2. `NetworkService` is called which dispatches the call to `PrimaryHub`
3. `PrimaryHub` forwards this event to the `ChatHandler` on the server
4. Server's `ChatHandler` dispatches messages via `SignalR` function  `clients.All.SendAsync` and send a response to the client
5. The response code is received by the client which can log or send a notification if there was an error

#### Receiver Flow

1. Server's `ChatHandler` dispatches messages via `SignalR` function  `clients.All.SendAsync`
2. Client's `ChatMessageRecievedHandler` (which is subscribed to `ChatReceivedMessage` for the `HubMethod.ReceiveChatMessage`network events), dispatches the update to `ChatUiController`
3. `ChatUiController` updates the UI state for the `ChatUiView` to be updated on the next frame.

## Database Layer

The data models are generated by `sqlc` the source of truth for the schema based on the SQL migration scripts the models is always the SQL migrations and the associated code.
For the server, the models follow the Database SQL, refer.

Important Schema nomenclature

- `Admin`: This is currently unused, but is created as it requires separated credentials for backend admin access
- `User`: Tied to the discord account for authentication purposes and Profile management
- `Profile`: A transparent UID that serves as an identity, they can be freely provisioned by the user via discord and can be linked freely to any characters.
- `Pair`: This provides the pairing with another users as well as the permissions granted to the other user. Pairing can be set as temporary by giving it an expiry.
